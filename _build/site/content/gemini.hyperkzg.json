{"version":2,"kind":"Notebook","sha256":"c46fbe84e0de2feb9a668c3c4d3237d2de83ac6ed78f74e58bda5e3ec84d0900","slug":"gemini.hyperkzg","location":"/gemini/hyperkzg.ipynb","dependencies":[],"frontmatter":{"kernelspec":{"name":"python3","display_name":"Python 3","language":"python"},"github":"https://github.com/executablebooks/jupyter-book","numbering":{"title":{"offset":1}},"edit_url":"https://github.com/executablebooks/jupyter-book/blob/main/gemini/hyperkzg.ipynb","exports":[{"format":"ipynb","filename":"hyperkzg.ipynb","url":"/hyperkzg-92f48f7ed83eb236f2b14fe6a9444bc1.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-content","data":{"vscode":{"languageId":"raw"}},"children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"The goal of this notebook is to show the working of HyperKZG PCS, and how it is better than Gemini PCS, when it comes to MLE polynomials provided in evaluation format.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"DUivWOmIfN"}],"key":"ip2bCd1W2C"},{"type":"paragraph","position":{"start":{"line":4,"column":1},"end":{"line":7,"column":1}},"children":[{"type":"text","value":"To run this notebook, you need to run the following commands:\n","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"U3Cgu0cj3h"},{"type":"inlineCode","value":"conda create -n sage sage python=3.12.5","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"KKxj9qwTxj"},{"type":"text","value":"\n","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"IELdX0Cgfs"},{"type":"inlineCode","value":"conda activate sage","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"csPRgMbgm5"},{"type":"text","value":"\n","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"SaTUdCkFtI"},{"type":"inlineCode","value":"sage -n jupyter","position":{"start":{"line":4,"column":1},"end":{"line":4,"column":1}},"key":"khKUOGQ2tY"}],"key":"j0ucxEDuLb"}],"key":"IjyMtrCkVu"},{"type":"block","kind":"notebook-code","data":{"jp-MarkdownHeadingCollapsed":true,"scrolled":true},"children":[{"type":"code","lang":"python","executable":true,"value":"# Define variables\nn = 3\nN = 2^n\nX = var(['X{}'.format(i) for i in range(n)]) # Define the variables X_0, X-1,.....\nu = var(['u{}'.format(i) for i in range(n)]) # Define the variables u_0, u-1,.....\n\n# Function to get binary representation as a list of bits\ndef bits(i,n):\n    return list(map(int, format(i,'0{}b'.format(n))))\n\ndef bits_reverse(i, n):\n    bits_list = bits(i, n)\n    return list(reversed(bits_list))\n\n# Define the eq_tilde function\ndef eq_tilde(bits_i, u_vector):\n    result=1\n    for bit,u in zip(bits_i,u_vector):\n        result *= (1-bit)*(1-u) + bit*u\n    return result\n\n# Coefficients of the polynomial\na = [var('a{}'.format(i)) for i in range(N)] # Coefficients a_0, a_1, ...., a_(N-1)\n\n# MLE polynomial\nf_tilde = sum(a[i]*eq_tilde(bits(i,n), X) for i in range(N))\n\nfor term in f_tilde.operands():\n    print(term)\n\n        \n# Generate all combinations of (1-u[i]) and u[i] based on binary representation\ndef generate_c_vector(n, u):\n    c_vector = []\n    for i in range(2^n):  # Loop over all binary numbers from 0 to 2^n - 1\n        binary = list(map(int, format(i, f'0{n}b')))  # Binary representation of i\n        binary_reverse = list(reversed(binary))  # Reverse the binary representation\n        product = 1\n        for j, bit in enumerate(binary_reverse):\n            if bit == 0:\n                product *= (1 - u[j])  # Use (1 - u[j]) for 0\n            else:\n                product *= u[j]  # Use u[j] for 1\n        c_vector.append(product)\n    return c_vector\n\n# Compute the c vector\nc = generate_c_vector(n, u)\n\n# Display the c vector\nshow(c)\n\n# Create a 3D plot of f_tilde\n# First, let's create a numerical version of f_tilde by substituting some values for coefficients\nimport numpy as np\n\n# Set some random coefficients for visualization\ncoeffs = [1, 2, 3, 4, 5, 6, 7, 8]  # 8 coefficients for n=3\n\n# Create a numerical function\ndef f_tilde_numerical(x0, x1, x2):\n    result = 0\n    for i in range(8):\n        bits_i = bits(i, 3)\n        result += coeffs[i] * eq_tilde(bits_i, [x0, x1, x2])\n    return result\n\n# Create points for all evaluations\npoints = []\nfor i in range(8):\n    bits_i = bits(i, 3)\n    x, y, z = bits_i\n    points.append((x, y, z, coeffs[i]))\n\n# Create point plot with axes labels\npoint_plot = point3d([(p[0], p[1], p[2]) for p in points], size=20, axes_labels=['X0', 'X1', 'X2'])\n\n# Create text labels with offset, only showing coordinate and a value\ntext_plots = []\n# offset = 0.22  # Spacing for clarity\n# fontsize = 16  # Large and readable\n\nfor i, p in enumerate(points):\n    label = f\"({p[0]},{p[1]},{p[2]})\\n\" + f\"a{i}={p[3]}\"\n    # If x=1, place label to the right; else to the left\n    if p[0] == 1:\n        label_pos = (p[0] , p[1], p[2])\n    else:\n        label_pos = (p[0] , p[1], p[2])\n    text_plots.append(text3d(label, label_pos, fontsize=20))\n\n# Combine all text labels into a single plot (no blue dots)\nfinal_plot = sum(text_plots)\nfinal_plot.show()\n\n# --- Separate a-vector display section ---\na_vector_text = \"a = [\" + \", \".join([f\"{c}\" for c in coeffs]) + \"]\"\nshow(html(f\"<pre style='font-size:14px'>{a_vector_text}</pre>\"))","key":"pwta5ptbiK"},{"type":"output","id":"OWKqvKiNfyBR1DY-87C1Z","data":[{"name":"stdout","output_type":"stream","text":"-(X0 - 1)*(X1 - 1)*(X2 - 1)*a0\n(X0 - 1)*(X1 - 1)*X2*a1\n(X0 - 1)*X1*(X2 - 1)*a2\n-(X0 - 1)*X1*X2*a3\nX0*(X1 - 1)*(X2 - 1)*a4\n-X0*(X1 - 1)*X2*a5\n-X0*X1*(X2 - 1)*a6\nX0*X1*X2*a7\n"},{"output_type":"display_data","metadata":{},"data":{"text/html":{"content":"<html>\\(\\displaystyle \\left[-{\\left(u_{0} - 1\\right)} {\\left(u_{1} - 1\\right)} {\\left(u_{2} - 1\\right)}, u_{0} {\\left(u_{1} - 1\\right)} {\\left(u_{2} - 1\\right)}, {\\left(u_{0} - 1\\right)} u_{1} {\\left(u_{2} - 1\\right)}, -u_{0} u_{1} {\\left(u_{2} - 1\\right)}, {\\left(u_{0} - 1\\right)} {\\left(u_{1} - 1\\right)} u_{2}, -u_{0} {\\left(u_{1} - 1\\right)} u_{2}, -{\\left(u_{0} - 1\\right)} u_{1} u_{2}, u_{0} u_{1} u_{2}\\right]\\)</html>","content_type":"text/html"},"text/latex":{"content":"$\\displaystyle \\left[-{\\left(u_{0} - 1\\right)} {\\left(u_{1} - 1\\right)} {\\left(u_{2} - 1\\right)}, u_{0} {\\left(u_{1} - 1\\right)} {\\left(u_{2} - 1\\right)}, {\\left(u_{0} - 1\\right)} u_{1} {\\left(u_{2} - 1\\right)}, -u_{0} u_{1} {\\left(u_{2} - 1\\right)}, {\\left(u_{0} - 1\\right)} {\\left(u_{1} - 1\\right)} u_{2}, -u_{0} {\\left(u_{1} - 1\\right)} u_{2}, -{\\left(u_{0} - 1\\right)} u_{1} u_{2}, u_{0} u_{1} u_{2}\\right]$","content_type":"text/latex"},"text/plain":{"content":"[-(u0 - 1)*(u1 - 1)*(u2 - 1),\n u0*(u1 - 1)*(u2 - 1),\n (u0 - 1)*u1*(u2 - 1),\n -u0*u1*(u2 - 1),\n (u0 - 1)*(u1 - 1)*u2,\n -u0*(u1 - 1)*u2,\n -(u0 - 1)*u1*u2,\n u0*u1*u2]","content_type":"text/plain"}}},{"output_type":"display_data","metadata":{},"data":{"text/html":{"content_type":"text/html","hash":"03ea857d192c39d9820a12204bc6c7fa","path":"/03ea857d192c39d9820a12204bc6c7fa.html"},"text/plain":{"content":"Graphics3d Object","content_type":"text/plain"}}},{"output_type":"display_data","metadata":{},"data":{"text/html":{"content":"<pre style='font-size:14px'>a = [1, 2, 3, 4, 5, 6, 7, 8]</pre>","content_type":"text/html"},"text/plain":{"content":"<pre style='font-size:14px'>a = [1, 2, 3, 4, 5, 6, 7, 8]</pre>","content_type":"text/plain"}}}],"key":"AxHpeXKULw"}],"key":"rLPXyceZcC"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"So we have the evaluation vector with us which represents the evaluation of a boolean hypercube at individual points. For n=3, we have the points from ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"eMQVBcbum7"},{"type":"inlineCode","value":"000","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"aBrdnEP3uC"},{"type":"text","value":" all the way up to ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"qzVO818dcb"},{"type":"inlineCode","value":"111","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"SiJzKxyt0x"},{"type":"text","value":".","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"SVzOptlu0Y"}],"key":"hNMKeuzarN"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":4,"column":1}},"children":[{"type":"text","value":"Now, in the Gemini Protocol, we take this evaluation vector, and convert this to the coefficient-value form using FFT/IFFT.\nThe followind code snippet shows that","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"S9oUtxVbpd"}],"key":"U6VyNu9pJc"}],"key":"LFmL3Zzhwz"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import sys\nimport os\n!pip install -q py-ecc\n\nsrc_path = os.path.abspath(os.path.join(\"..\", \"src\"))\nif src_path not in sys.path:\n    sys.path.append(src_path)\n\n# Define variables\nn = 3\nN = 2^n\nX = var(['X{}'.format(i) for i in range(n)]) # Define the variables X_0, X-1,.....\nu = var(['u{}'.format(i) for i in range(n)]) # Define the variables u_0, u-1,.....\n\n# Function to get binary representation as a list of bits\ndef bits(i,n):\n    return list(map(int, format(i,'0{}b'.format(n))))\n\ndef bits_reverse(i, n):\n    bits_list = bits(i, n)\n    return list(reversed(bits_list))\n\n# Define the eq_tilde function\ndef eq_tilde(bits_i, u_vector):\n    result=1\n    for bit,u in zip(bits_i,u_vector):\n        result *= (1-bit)*(1-u) + bit*u\n    return result\n\ndef generate_c_vector(n, u):\n    c_vector = []\n    for i in range(2^n):  # Loop over all binary numbers from 0 to 2^n - 1\n        binary = list(map(int, format(i, f'0{n}b')))  # Binary representation of i\n        binary_reverse = list(reversed(binary))  # Reverse the binary representation\n        product = 1\n        for j, bit in enumerate(binary_reverse):\n            if bit == 0:\n                product *= (1 - u[j])  # Use (1 - u[j]) for 0\n            else:\n                product *= u[j]  # Use u[j] for 1\n        c_vector.append(product)\n    return c_vector\n\nfrom mle2 import MLEPolynomial\nfrom curve import Fr as BN254_Fr\n\nMLEPolynomial.set_field_type(BN254_Fr)\n\nevals = [1, 2, 3, 4, 5, 6, 7, 8]\nprint(\"Original evaluation at individual points\")\nprint(f\"evals = {[str(x) for x in evals]}\\n\")\n\nevals = [BN254_Fr(int(x)) for x in evals]\ncoeffs = MLEPolynomial.compute_coeffs_from_evals(evals)\nprint(\"Coefficients after NTT:\")\nprint(f\"coeffs = {[str(x) for x in coeffs]}\\n\")\n\nprint(\"What does this mean?\\n\")\n\n# Step 1: Setup for symbolic MLE polynomial\nN = len(evals)\nn = 3  # log2(N)\nX = var(['X{}'.format(i) for i in range(n)])\n\nprint(\"MLE polynomial in evaluation form:\\n\")\nfor i in range(N):\n    term = eq_tilde(bits(i, n), X)\n    print(f\"a[{i}] = {evals[i]} => term = {evals[i]}*({term})\")\n\nprint(\"\\ngets converted to the coefficient form, which is:\\n\")\n\n\nprint(\"Symbolic monomial basis (c_i * monomial):\")\nfor i in range(len(coeffs)):\n    i_bits = bits(i, n)\n    monomial_terms = [f\"X{j}\" for j, b in enumerate(i_bits) if b == 1]\n    monomial = \"*\".join(monomial_terms) if monomial_terms else \"1\"\n    print(f\"c{i} * {monomial}\")\n\n\nprint(\"\\nReal-valued coefficient vector:\")\nprint(f\"coeffs = {[str(c) for c in coeffs]}\")\n\n\nprint(\"\\nFull coefficient form (including zero coefficients):\")\nfor i in range(len(coeffs)):\n    mon_bits = bits(i, n)\n    monomial = \"*\".join([f\"X{j}\" if b == 1 else \"1\" for j, b in enumerate(mon_bits)])\n    coeff = coeffs[i]\n    print(f\"coeffs[{i}] = {coeff} => term = {coeff}*{monomial}\")\n\nprint(\"\\n\\\\ie. the coefficient form of the same multilinear extension\")","key":"lsLYJy9Yrc"},{"type":"output","id":"mnJjMJQ1bYyKopQZ_Dmd-","data":[{"name":"stdout","output_type":"stream","text":"Original evaluation at individual points\nevals = ['1', '2', '3', '4', '5', '6', '7', '8']\n\nCoefficients after NTT:\ncoeffs = ['1', '1', '2', '0', '4', '0', '0', '0']\n\nWhat does this mean?\n\nMLE polynomial in evaluation form:\n\na[0] = 1 => term = 1*(-(X0 - 1)*(X1 - 1)*(X2 - 1))\na[1] = 2 => term = 2*((X0 - 1)*(X1 - 1)*X2)\na[2] = 3 => term = 3*((X0 - 1)*X1*(X2 - 1))\na[3] = 4 => term = 4*(-(X0 - 1)*X1*X2)\na[4] = 5 => term = 5*(X0*(X1 - 1)*(X2 - 1))\na[5] = 6 => term = 6*(-X0*(X1 - 1)*X2)\na[6] = 7 => term = 7*(-X0*X1*(X2 - 1))\na[7] = 8 => term = 8*(X0*X1*X2)\n\ngets converted to the coefficient form, which is:\n\nSymbolic monomial basis (c_i * monomial):\nc0 * 1\nc1 * X2\nc2 * X1\nc3 * X1*X2\nc4 * X0\nc5 * X0*X2\nc6 * X0*X1\nc7 * X0*X1*X2\n\nReal-valued coefficient vector:\ncoeffs = ['1', '1', '2', '0', '4', '0', '0', '0']\n\nFull coefficient form (including zero coefficients):\ncoeffs[0] = 1 => term = 1*1*1*1\ncoeffs[1] = 1 => term = 1*1*1*X2\ncoeffs[2] = 2 => term = 2*1*X1*1\ncoeffs[3] = 0 => term = 0*1*X1*X2\ncoeffs[4] = 4 => term = 4*X0*1*1\ncoeffs[5] = 0 => term = 0*X0*1*X2\ncoeffs[6] = 0 => term = 0*X0*X1*1\ncoeffs[7] = 0 => term = 0*X0*X1*X2\n\n\\ie. the coefficient form of the same multilinear extension\n"}],"key":"biyUU2otPC"}],"key":"qJfy1mcGJq"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"From the above code snippet, it can be seen that conversion from Evaluation vector to Coefficient Vector requires the use of ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"BmPfsEZPOU"},{"type":"inlineCode","value":"ntt_core","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"BlHXFEgnJF"},{"type":"text","value":" function which takes ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"mfXF1GKx3i"},{"type":"inlineCode","value":"O(NlogN)","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"rtSWJpb2zV"},{"type":"text","value":" time.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"W5MANH2xRV"}],"key":"Sw1esJ4pXw"}],"key":"egNydefou7"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"The next step is mapping this is ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"uxpooLe7hh"},{"type":"inlineCode","value":"coefficient vector","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"iGs454ZOgR"},{"type":"text","value":" i.e. ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"ZQT5UdrJxY"},{"type":"inlineCode","value":"['1', '1', '2', '0', '4', '0', '0', '0']","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"JZY20GRRU1"},{"type":"text","value":" to a univariate polynomial and then use the ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"xkv4oIXscJ"},{"type":"inlineCode","value":"split-and-fold","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"NrFXKWIhdQ"},{"type":"text","value":" technique thereafter. There is where the difference between Gemini and HyperKZG comes in.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"GR8MSzcZGV"}],"key":"bOd8XOhLCm"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"So, if we already have a coefficient form of a MLE-polynomial, we won’t need the conversion from evaluation format. But what if we are presented with the evaluation form of the MLE polynomial. In case of Gemini, we will always be needing to first convert it to the coefficient form and then do the mapping. Instead, in the case of HyperKZG we do not need this conversion, therefore, be it evaluation form or coefficient form of the MLE, there is no effect on the time for proof generation.","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"BWFwYpJWm3"}],"key":"i12Oyu45sk"},{"type":"paragraph","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"children":[{"type":"text","value":"Let’s see how this works.","position":{"start":{"line":5,"column":1},"end":{"line":5,"column":1}},"key":"wsurIBTiIU"}],"key":"ZTl5OPnDIu"}],"key":"xyXjhxxWXi"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import sys\nimport os\n!pip install -q py-ecc\n\n# Define variables\nn = 3\nN = 2^n\nX = var(['X{}'.format(i) for i in range(n)]) # Define the variables X_0, X-1,.....\nu = var(['u{}'.format(i) for i in range(n)]) # Define the variables u_0, u-1,.....\n\n# Function to get binary representation as a list of bits\ndef bits(i,n):\n    return list(map(int, format(i,'0{}b'.format(n))))\n\ndef bits_reverse(i, n):\n    bits_list = bits(i, n)\n    return list(reversed(bits_list))\n\n# Define the eq_tilde function\ndef eq_tilde(bits_i, u_vector):\n    result=1\n    for bit,u in zip(bits_i,u_vector):\n        result *= (1-bit)*(1-u) + bit*u\n    return result\n\nfrom mle2 import MLEPolynomial\nfrom curve import Fr as BN254_Fr\n\nMLEPolynomial.set_field_type(BN254_Fr)\nevals = [1, 2, 3, 4, 5, 6, 7, 8]  \n\nevals = [BN254_Fr(int(x)) for x in evals] \ncoeffs = MLEPolynomial.compute_coeffs_from_evals(evals)\n# print(\"Coefficients after NTT:\")\n\n\nprint(\"Gemini: Mapping the coefficient vector to a unvariate polynomial\\n\")\n\nprint(f\"coeffs = {[str(x) for x in coeffs]}\\n\")\n\ndef uni_eval_from_coeffs(coeffs, z):\n    return sum(int(coeffs[i]) * z**i for i in range(len(coeffs)))\n\nx = var('X')  # Symbolic variable for univariate polynomial\nunivariate_poly_gemini = uni_eval_from_coeffs(coeffs, x)\n\n# 1. Symbolic representation (using c0, c1, ..., c7)\nsymbolic_terms = [f\"c{i}*X^{i}\" for i in range(len(coeffs))]\nsymbolic_poly_str = \" + \".join(symbolic_terms)\nprint(\"Symbolic coefficient form (before assigning actual values):\")\nprint(symbolic_poly_str)\n\n# 2. Actual coefficient vector\nprint(\"\\nReal-valued coefficient vector:\")\nprint(f\"coeffs = {[str(x) for x in coeffs]}\")\n\n# 3. Final univariate polynomial in explicit form\nterms = [f\"{coeffs[i]}*X^{i}\" for i in range(len(coeffs))]\npoly_str = \" + \".join(terms)\nprint(\"\\nUnivariate polynomial (explicit form with zero coeffs):\")\nprint(poly_str)\n\n# 4. Evaluatable symbolic polynomial expression (optional, for display)\nx = var('X')  # symbolic variable\nunivariate_poly_gemini = sum(int(coeffs[i]) * x**i for i in range(len(coeffs)))\nprint(\"\\nSimplified symbolic expression (optional):\")\nprint(univariate_poly_gemini)\nprint(\"\\n\")\nprint(\"HyperKZG: Mapping the evaluation vector to a unvariate polynomial\\n\")\nprint(\"Original evaluation at individual points\")\nprint(f\"evals = {[str(x) for x in evals]}\\n\")\nunivariate_poly_hyperKZG = uni_eval_from_coeffs(evals, x)\nprint(univariate_poly_hyperKZG)\n","key":"vC14IwJMde"},{"type":"output","id":"5hxbS9FnBSu8It-5sD7o6","data":[{"name":"stdout","output_type":"stream","text":"Gemini: Mapping the coefficient vector to a unvariate polynomial\n\ncoeffs = ['1', '1', '2', '0', '4', '0', '0', '0']\n\nSymbolic coefficient form (before assigning actual values):\nc0*X^0 + c1*X^1 + c2*X^2 + c3*X^3 + c4*X^4 + c5*X^5 + c6*X^6 + c7*X^7\n\nReal-valued coefficient vector:\ncoeffs = ['1', '1', '2', '0', '4', '0', '0', '0']\n\nUnivariate polynomial (explicit form with zero coeffs):\n1*X^0 + 1*X^1 + 2*X^2 + 0*X^3 + 4*X^4 + 0*X^5 + 0*X^6 + 0*X^7\n\nSimplified symbolic expression (optional):\n4*X^4 + 2*X^2 + X + 1\n\n\nHyperKZG: Mapping the evaluation vector to a unvariate polynomial\n\nOriginal evaluation at individual points\nevals = ['1', '2', '3', '4', '5', '6', '7', '8']\n\n8*X^7 + 7*X^6 + 6*X^5 + 5*X^4 + 4*X^3 + 3*X^2 + 2*X + 1\n"}],"key":"Yuk7AQ9yR0"}],"key":"nZ8jWvVVhS"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import sys\nimport os\n!pip install -q py-ecc\n\n# Define variables\nn = 3\nN = 2^n\nX = var(['X{}'.format(i) for i in range(n)]) # Define the variables X_0, X-1,.....\nu = var(['u{}'.format(i) for i in range(n)]) # Define the variables u_0, u-1,.....\n\n# Function to get binary representation as a list of bits\ndef bits(i,n):\n    return list(map(int, format(i,'0{}b'.format(n))))\n\ndef bits_reverse(i, n):\n    bits_list = bits(i, n)\n    return list(reversed(bits_list))\n\n# Define the eq_tilde function\ndef eq_tilde(bits_i, u_vector):\n    result=1\n    for bit,u in zip(bits_i,u_vector):\n        result *= (1-bit)*(1-u) + bit*u\n    return result\n\nfrom mle2 import MLEPolynomial\nfrom curve import Fr as BN254_Fr\n\nMLEPolynomial.set_field_type(BN254_Fr)\nevals = [1, 2, 3, 4, 5, 6, 7, 8]  \n\nevals = [BN254_Fr(int(x)) for x in evals] \ncoeffs = MLEPolynomial.compute_coeffs_from_evals(evals)\n# print(\"Coefficients after NTT:\")\n\n\nprint(\"Gemini: Mapping the coefficient vector to a unvariate polynomial\\n\")\n\nprint(f\"coeffs = {[str(x) for x in coeffs]}\\n\")\n\ndef uni_eval_from_coeffs(coeffs, z):\n    return sum(int(coeffs[i]) * z**i for i in range(len(coeffs)))\n\nx = var('X')  # Symbolic variable for univariate polynomial\nunivariate_poly_gemini = uni_eval_from_coeffs(coeffs, x)\n\n# 1. Symbolic representation (using c0, c1, ..., c7)\nsymbolic_terms = [f\"c{i}*X^{i}\" for i in range(len(coeffs))]\nsymbolic_poly_str = \" + \".join(symbolic_terms)\nprint(\"Symbolic coefficient form (before assigning actual values):\")\nprint(symbolic_poly_str)\n\n# 2. Actual coefficient vector\nprint(\"\\nReal-valued coefficient vector:\")\nprint(f\"coeffs = {[str(x) for x in coeffs]}\")\n\n# 3. Final univariate polynomial in explicit form\nterms = [f\"{coeffs[i]}*X^{i}\" for i in range(len(coeffs))]\npoly_str = \" + \".join(terms)\nprint(\"\\nUnivariate polynomial (explicit form with zero coeffs):\")\nprint(poly_str)\n\n# 4. Evaluatable symbolic polynomial expression (optional, for display)\nx = var('X')  # symbolic variable\nunivariate_poly_gemini = sum(int(coeffs[i]) * x**i for i in range(len(coeffs)))\nprint(\"\\nSimplified symbolic expression (optional):\")\nprint(univariate_poly_gemini)\nprint(\"\\n\")\nprint(\"HyperKZG: Mapping the evaluation vector to a unvariate polynomial\\n\")\nprint(\"Original evaluation at individual points\")\nprint(f\"evals = {[str(x) for x in evals]}\\n\")\nunivariate_poly_hyperKZG = uni_eval_from_coeffs(evals, x)\nprint(univariate_poly_hyperKZG)\n","key":"i2VFbdQ4qf"},{"type":"output","id":"_g0oTAvmJ5zfwT3lbCA9G","data":[{"name":"stdout","output_type":"stream","text":"Gemini: Mapping the coefficient vector to a unvariate polynomial\n\ncoeffs = ['1', '1', '2', '0', '4', '0', '0', '0']\n\nSymbolic coefficient form (before assigning actual values):\nc0*X^0 + c1*X^1 + c2*X^2 + c3*X^3 + c4*X^4 + c5*X^5 + c6*X^6 + c7*X^7\n\nReal-valued coefficient vector:\ncoeffs = ['1', '1', '2', '0', '4', '0', '0', '0']\n\nUnivariate polynomial (explicit form with zero coeffs):\n1*X^0 + 1*X^1 + 2*X^2 + 0*X^3 + 4*X^4 + 0*X^5 + 0*X^6 + 0*X^7\n\nSimplified symbolic expression (optional):\n4*X^4 + 2*X^2 + X + 1\n\n\nHyperKZG: Mapping the evaluation vector to a unvariate polynomial\n\nOriginal evaluation at individual points\nevals = ['1', '2', '3', '4', '5', '6', '7', '8']\n\n8*X^7 + 7*X^6 + 6*X^5 + 5*X^4 + 4*X^3 + 3*X^2 + 2*X + 1\n"}],"key":"Z15wdQGCnT"}],"key":"VqX1UlJYuo"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"As it can be seen, we are mapping the coefficient vector to univariate polynomial for Gemini, and for HyperKZG, we use the evaluation vector i.e. ","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"VpTyHXdln0"},{"type":"inlineCode","value":"[1, 2, 3, 4, 5, 6, 7, 8]","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"WPYvNisfBB"}],"key":"IIepFzVDnV"}],"key":"EI92jHfSAH"},{"type":"block","kind":"notebook-content","children":[{"type":"code","lang":"","value":"                                    --------------------------------------------\n            ``HOW and WHY can we map the MLE Evaluation form and Coefficient form to a Univariate Polynomial ?``","position":{"start":{"line":1,"column":1},"end":{"line":2,"column":1}},"key":"yuNroa2K7d"}],"key":"imabifhMUG"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"## Explanation to be added soon","key":"qJdHAwrEey"},{"type":"output","id":"tfU4l-hruFQrJxmT5x8FY","data":[],"key":"Bfx4MuZvTO"}],"key":"DpBUdZzl8s"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"So we have both our polynomials in the univariate form, from Evaluation to UniPoly as well as from Coefficients to UniPoly. Next step is to show how we can reduce down these univariate polynomials through the split-and-fold technique.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"QaABNFEFwh"}],"key":"T9Qi6nCzmA"},{"type":"paragraph","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"children":[{"type":"text","value":"Let’s see how this works:","position":{"start":{"line":3,"column":1},"end":{"line":3,"column":1}},"key":"PTeXmfF1fz"}],"key":"KiizzzxRKw"}],"key":"qtz1EdrVNY"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"import sys\nimport os\n!pip install -q py-ecc\n\n# Define variables\nn = 3\nN = 2^n\nX = var(['X{}'.format(i) for i in range(n)]) # Define the variables X_0, X-1,.....\nu = var(['u{}'.format(i) for i in range(n)]) # Define the variables u_0, u-1,.....\n\n# Function to get binary representation as a list of bits\ndef bits(i,n):\n    return list(map(int, format(i,'0{}b'.format(n))))\n\ndef bits_reverse(i, n):\n    bits_list = bits(i, n)\n    return list(reversed(bits_list))\n\n# Define the eq_tilde function\ndef eq_tilde(bits_i, u_vector):\n    result=1\n    for bit,u in zip(bits_i,u_vector):\n        result *= (1-bit)*(1-u) + bit*u\n    return result\n\nfrom mle2 import MLEPolynomial\nfrom curve import Fr as BN254_Fr\nfrom hyperkzg_pcs import HYPERKZG_PCS                        \nfrom unipoly import UniPolynomial\nfrom curve import Fr as Field\n\nprint(\"\\nCreating multilinear polynomial f and univariate polynomial g(X)...\")\n\n# 1) multilinear polynomial f  (from the evaluation vector we already have)\nf_mle = MLEPolynomial(evals,3)                # BN254 field is already set\n\n# 2) univariate poly g(X)  =  uₙ(evals)\ng_uni = UniPolynomial(evals)                # coefficients are evals[i]\n\nprint(\"\\nUnivariate poly via HYPERKZG map   g(X) =\")\nprint(g_uni)              \n\nx = var('X')                      # univariate indeterminate\ndef vec_poly(vec):                # vector → symbolic poly  P(X)=Σv[i]·X^i\n    return sum(int(v) * x**i for i, v in enumerate(vec))\n\ndef official_fold_verbose(f_eval_vec, u_vec):\n    print(\"\\n_____ HyperKZG fold __________________________________\")\n    h = f_eval_vec[:]                                     # h⁰\n    print(\"h⁰ =\", [int(v) for v in h])\n\n    for k, u_k in enumerate(u_vec):\n        print(f\"\\nStep {k+1}:  u_{k} = {int(u_k)}\")\n        h_even = h[::2]\n        h_odd  = h[1::2]\n        print(\"  h_even =\", [int(v) for v in h_even])\n        print(\"  h_odd  =\", [int(v) for v in h_odd])\n\n        # build h_next element-by-element and show each computation\n        h_next = []\n        for idx, (a, b) in enumerate(zip(h_even, h_odd)):\n            new_val = a + u_k * (b - a)\n            h_next.append(new_val)\n            print(f\"   h_next[{idx}] = {int(a)} + {int(u_k)}·({int(b)}−{int(a)}) = {int(new_val)}\")\n\n        print(\"  h_next =\", [int(v) for v in h_next])\n\n        # Eq.(24) verification\n        h_i_expr   = vec_poly(h)\n        h_ip1_expr = vec_poly(h_next)\n        h_i_neg    = h_i_expr.subs({x: -x})\n        u_int      = int(u_k)\n        rhs        = expand((1-u_int)*(h_i_expr + h_i_neg)/2 +\n                            u_int     *(h_i_expr - h_i_neg)/(2*x))\n        lhs        = h_ip1_expr.subs({x: x**2})\n        print(\"  LHS = h^{%d}(X²) =\" % (k+1), lhs)\n        print(\"  RHS              =\", rhs)\n        print(\"  LHS − RHS        =\", expand(lhs - rhs))\n\n        h = h_next                                       # advance to next stage\n\n    print(\"\\nFinal folded constant =\", int(h[0]))\n    return h[0]\n\ndef bits_le(i, n=3):\n    return [(i >> j) & 1 for j in range(n)]\n\ndef delta(bits_i, u_vec):\n    one = Field(int(1))\n    out = Field(int(1))\n    for j, (bit, u) in enumerate(zip(bits_i, u_vec)):\n        bit_f = Field(int(bit))\n        term = (one - bit_f) * (one - u) + bit_f * u\n        out  *= term\n    return out\n\n\n# choose challenge points\nu_vals = [Field(int(v)) for v in (2, 5, 3)]\nprint(\"\\nChallenge point vector u =\", [int(v) for v in u_vals])\n\n# run folding\nfold_constant = official_fold_verbose(evals, u_vals)\n\n# direct MLE evaluation \nprint(\"\\nComputing direct evaluation of f(u) using δ̃...\")\ndirect = Field(int(0))\nfor i, e in enumerate(evals):\n    b = bits_le(i)\n    d = delta(b, u_vals)\n    term = e * d\n    direct += term\nprint(direct)\n\nprint(\"\\n========= Final Check =========\")\nprint(\"Constant after folds =\", int(fold_constant))\nprint(\"Direct f(u)          =\", int(direct))\nprint(\"Match?               →\", fold_constant == direct)","key":"XSK5qHuh9Y"},{"type":"output","id":"BX6iYbkHQ60IDTVo0uDyU","data":[{"name":"stdout","output_type":"stream","text":"\nCreating multilinear polynomial f and univariate polynomial g(X)...\n\nUnivariate poly via HYPERKZG map   g(X) =\n1 + 2x + 3x^2 + 4x^3 + 5x^4 + 6x^5 + 7x^6 + 8x^7\n\nChallenge point vector u = [2, 5, 3]\n\n_____ HyperKZG fold __________________________________\nh⁰ = [1, 2, 3, 4, 5, 6, 7, 8]\n\nStep 1:  u_0 = 2\n  h_even = [1, 3, 5, 7]\n  h_odd  = [2, 4, 6, 8]\n   h_next[0] = 1 + 2·(2−1) = 3\n   h_next[1] = 3 + 2·(4−3) = 5\n   h_next[2] = 5 + 2·(6−5) = 7\n   h_next[3] = 7 + 2·(8−7) = 9\n  h_next = [3, 5, 7, 9]\n  LHS = h^{1}(X²) = 9*X^6 + 7*X^4 + 5*X^2 + 3\n  RHS              = 9*X^6 + 7*X^4 + 5*X^2 + 3\n  LHS − RHS        = 0\n\nStep 2:  u_1 = 5\n  h_even = [3, 7]\n  h_odd  = [5, 9]\n   h_next[0] = 3 + 5·(5−3) = 13\n   h_next[1] = 7 + 5·(9−7) = 17\n  h_next = [13, 17]\n  LHS = h^{2}(X²) = 17*X^2 + 13\n  RHS              = 17*X^2 + 13\n  LHS − RHS        = 0\n\nStep 3:  u_2 = 3\n  h_even = [13]\n  h_odd  = [17]\n   h_next[0] = 13 + 3·(17−13) = 25\n  h_next = [25]\n  LHS = h^{3}(X²) = 25\n  RHS              = 25\n  LHS − RHS        = 0\n\nFinal folded constant = 25\n\nComputing direct evaluation of f(u) using δ̃...\n25\n\n========= Final Check =========\nConstant after folds = 25\nDirect f(u)          = 25\nMatch?               → True\n"}],"key":"RNay8rK4Kp"}],"key":"gKWv9PwRoe"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"\nimport sys, os\n!pip install -q py-ecc\n\n\nfrom curve     import Fr  as Field\nfrom mle2      import MLEPolynomial\nfrom bcho_pcs  import BCHO_PCS           \nfrom unipoly   import UniPolynomial\nfrom curve     import Fr as BN254_Fr\n\n\nn = 3\nx = var('X')\n\ndef bits_le(i, n=n):\n    \"\"\"little-endian bits list\"\"\"\n    return [(i >> j) & 1 for j in range(n)]\n\ndef vec_poly(vec):\n    \"\"\"vector → Σ vec[i]·X^i\"\"\"\n    return sum(int(v)*x**i for i,v in enumerate(vec))\n\ndef delta(bits_i, u_vec):\n    \"\"\"δ̃_i(u) in the BN254 field\"\"\"\n    one = Field(int(1))\n    out = Field(int(1))\n    for bit, u in zip(bits_i, u_vec):\n        bit_f = Field(int(bit))\n        out  *= (one-bit_f)*(one-u) + bit_f*u\n    return out\n\n\nevals  = [Field(int(v)) for v in (1,2,3,4,5,6,7,8)]\nprint(\"evaluations=\",evals)\n\nMLEPolynomial.set_field_type(BN254_Fr)\ncoeffs = MLEPolynomial.compute_coeffs_from_evals(evals)  \nprint(\"coeffs =\", [int(c) for c in coeffs])\n\ng_uni  = UniPolynomial(coeffs)                 \nprint(\"\\nUnivariate poly P(X) =\", g_uni)\n\n\ndef gemini_fold_verbose(c_vec, u_vec):\n    print(\"\\n________  Gemini split-and-fold  ________\")\n    c = c_vec[:]                                         \n    print(\"c⁰ =\", [int(v) for v in c])\n\n    for k, u_k in enumerate(u_vec):\n        print(f\"\\nStep {k+1}, u_{k} = {int(u_k)}\")\n\n        # split\n        c_even, c_odd = c[::2], c[1::2]\n        print(\"  c_even =\", [int(v) for v in c_even])\n        print(\"  c_odd  =\", [int(v) for v in c_odd])\n\n        # update  c_next[i] = c_even[i] + u·c_odd[i]\n        c_next = []\n        for idx, (a, b) in enumerate(zip(c_even, c_odd)):\n            new = a + u_k * b\n            c_next.append(new)\n            print(f\"   c_next[{idx}] = {int(a)} + {int(u_k)}·{int(b)} = {int(new)}\")\n        print(\"  c_next =\", [int(v) for v in c_next])\n\n        # ----- verify Eq.(13):  Q(X²) = (P+P(−X))/2 + u·(P−P(−X))/(2X)\n        P      = vec_poly(c)          # current poly  P(X)\n        P_neg  = P.subs({x: -x})\n        Q      = vec_poly(c_next)     # poly after the fold\n        u_int  = int(u_k)\n\n        lhs = Q.subs({x: x**2})\n        rhs = expand((P + P_neg)/Integer(2) +\n                     u_int * (P - P_neg)/(Integer(2)*x))\n\n        print(\"  LHS = Q(X²) =\", lhs)\n        print(\"  RHS         =\", rhs)\n        print(\"  LHS − RHS   =\", expand(lhs - rhs))\n\n        c = c_next                    # proceed to next round\n\n    print(\"\\nFinal folded constant =\", int(c[0]))\n    return c[0]    \nu_vals = [Field(int(v)) for v in (2,5,3)]\nprint(\"evaluation point=\",u_vals)\nfold_const = gemini_fold_verbose(coeffs, u_vals)\n\n# ----------------------------- direct evaluation check ---------------------------\ndirect = Field(int(0))\nfor i, e in enumerate(evals):\n    b = bits_le(i)\n    d = delta(b, u_vals)\n    term = e * d\n    direct += term\nprint(direct)\n\nprint(\"\\n=========  Check  =========\")\nprint(\"Constant after folds =\", int(fold_const))\nprint(\"Direct f(u)          =\", int(direct))\nprint(\"Match?               →\", fold_const == direct)\n","key":"wcQsmuJ7pD"},{"type":"output","id":"qBuBIDK3ykflmLMYUFHpp","data":[{"name":"stdout","output_type":"stream","text":"evaluations= [1, 2, 3, 4, 5, 6, 7, 8]\ncoeffs = [1, 1, 2, 0, 4, 0, 0, 0]\n\nUnivariate poly P(X) = 1 + x + 2x^2 + 4x^4\nevaluation point= [2, 5, 3]\n\n________  Gemini split-and-fold  ________\nc⁰ = [1, 1, 2, 0, 4, 0, 0, 0]\n\nStep 1, u_0 = 2\n  c_even = [1, 2, 4, 0]\n  c_odd  = [1, 0, 0, 0]\n   c_next[0] = 1 + 2·1 = 3\n   c_next[1] = 2 + 2·0 = 2\n   c_next[2] = 4 + 2·0 = 4\n   c_next[3] = 0 + 2·0 = 0\n  c_next = [3, 2, 4, 0]\n  LHS = Q(X²) = 4*X^4 + 2*X^2 + 3\n  RHS         = 4*X^4 + 2*X^2 + 3\n  LHS − RHS   = 0\n\nStep 2, u_1 = 5\n  c_even = [3, 4]\n  c_odd  = [2, 0]\n   c_next[0] = 3 + 5·2 = 13\n   c_next[1] = 4 + 5·0 = 4\n  c_next = [13, 4]\n  LHS = Q(X²) = 4*X^2 + 13\n  RHS         = 4*X^2 + 13\n  LHS − RHS   = 0\n\nStep 3, u_2 = 3\n  c_even = [13]\n  c_odd  = [4]\n   c_next[0] = 13 + 3·4 = 25\n  c_next = [25]\n  LHS = Q(X²) = 25\n  RHS         = 25\n  LHS − RHS   = 0\n\nFinal folded constant = 25\n25\n\n=========  Check  =========\nConstant after folds = 25\nDirect f(u)          = 25\nMatch?               → True\n"}],"key":"t6A1oumBZf"}],"key":"FqhK1AUyug"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Now, finally we can have a look at the full commit-> prove-> verify process of HyperKZG. Let’s see how that would look like:","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"lGc0ah8GGE"}],"key":"IHl8JihTVL"}],"key":"RQ3Tpq6pdU"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"\n\nfrom curve            import Fr  as Field, G1Point as G1, G2Point as G2\nfrom kzg10_non_hiding import KZG10_PCS\nfrom hyperkzg_pcs     import HYPERKZG_PCS\nfrom mle2             import MLEPolynomial\nfrom unipoly          import UniPolynomial\nfrom merlin.merlin_transcript import MerlinTranscript\n\n\nevals = [Field(v) for v in range(1, 9)]          # [1,2,3,4,5,6,7,8]\nf      = MLEPolynomial(evals, 3)                 # multilinear poly\nprint(f\"\\n f.evals = {[int(e) for e in evals]}\")\n\n\nkzg = KZG10_PCS(G1, G2, Field, 20, debug=True)   # SRS supports deg ≤ 19\nhyper = HYPERKZG_PCS(kzg, debug=True)\n\n\nP_uni = UniPolynomial(f.evals)                   # P(X)=Σ evals[i] X^i\nf_cm  = kzg.commit(P_uni)\n\nprint(\"\\n    commitment C    =\", f_cm)\n\n# ---------------- transcript ----------------------------------------------------\ntr = MerlinTranscript(b\"demo-hyperkzg\")\nprint(\" transcript initialised\")\n\n# ---------------- evaluation point & expected value ----------------------------\nu_point = [Field(int(2)), Field(int(5)), Field(int(3))]\nvalue   = f.evaluate(u_point)\nprint(\"\\n point u =\", [int(u) for u in u_point])\nprint(\"    f(u)    =\", int(value))\n\n# ---------------- prover   ------------------------------------------------------\nprint(\"\\n prover: split-and-fold + KZG opening (debug prints follow)\")\nval, proof = hyper.prove_eval(f_cm,\n                              f,                # multilinear polynomial\n                              u_point,\n                              transcript = tr.fork(b\"hyperkzg_pcs\"),\n                              debug      = 0)\nprint(\"\\n prover returns\")\nprint(\"    value =\", int(val))\nprint(\"    proof =\", proof)\n\n# ---------------- verifier ------------------------------------------------------\nprint(\"\\n verifier checking …\")\nok = hyper.verify_eval(f_cm,\n                       proof,\n                       u_point,\n                       val,\n                       tr.fork(b\"hyperkzg_pcs\"),\n                       debug = 0)\nprint(\"\\n verifier verdict =\", ok)\nassert ok\nprint(\"\\n✅ commit / prove / verify (n = 3, evals 1-8) succeeded\")\n","key":"cKyD8yazK0"},{"type":"output","id":"JR5t_em-1bccK5ZyipZrd","data":[{"name":"stdout","output_type":"stream","text":"\n f.evals = [1, 2, 3, 4, 5, 6, 7, 8]\n\n    commitment C    = Commitment((1506812733088703036033234108263636167068070115043288394654696824369162753701, 6768976303707139693812897756116472395786482991788971963782101192212253147496))\n transcript initialised\n\n point u = [2, 5, 3]\n    f(u)    = 25\n\n prover: split-and-fold + KZG opening (debug prints follow)\n\n prover returns\n    value = 25\n    proof = {'h_poly_cm_vec': [Commitment((12639462353244010680381447368452078110804438495068713582928834100037754862265, 10866247309917626445353569018798471704498055674764137457556639609877370593858)), Commitment((4980580926989182459414445441806082896302700826507243621831503156722784301198, 14343466145928105863220159096908656068831682711784830237508107782651444368178))], 'evals_pos_beta': [2277209654400165544615964393156358858988247296874751437304457084, 5252628250030167080666728524, 14206714084], 'evals_neg_beta': [-2277209649631505683588547399815675656631316148717517213283000732, -5252628240252900140417276952, -14206714058], 'evals_sq_beta': [-3955594603053139638151980260081843493791145249012257419901503569031308540649], 'q_commitment': Commitment((2635387625843308484255552685159514688383368642129920165780871653565008501558, 15948425198708495238991396757085884666348775208544013416592996687221504343277)), 'kzg_arg_r_poly_at_zeta': {'w_cm': Commitment((4059074833467054047170109586804814373337588538562910438833302514557790528212, 21312470642710428133652830969116880431811252487232356726015780891924047759582))}}\n\n verifier checking …\n\n verifier verdict = True\n\n✅ commit / prove / verify (n = 3, evals 1-8) succeeded\n"}],"key":"P8DruZGil5"}],"key":"O26kxQGWho"}],"key":"ZRui4DID6K"},"references":{"cite":{"order":[],"data":{}}}}
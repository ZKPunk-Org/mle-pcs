
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Notes on Basefold (Part V): IOPP Soundness &#8212; Polynomial Commitment Schemes</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b76e3c8a" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'basefold/basefold-05';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.png" class="logo__image only-light" alt="Polynomial Commitment Schemes - Home"/>
    <script>document.write(`<img src="../_static/logo.png" class="logo__image only-dark" alt="Polynomial Commitment Schemes - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Welcome to the land of PCS!
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Basefold</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="basefold-01.zh.html">Basefold 笔记：可折叠线性编码</a></li>
<li class="toctree-l1"><a class="reference internal" href="basefold-02.zh.html">Basefold 笔记：IOPP</a></li>
<li class="toctree-l1"><a class="reference internal" href="basefold-03.zh.html">Basefold 笔记： MLE 求值证明</a></li>
<li class="toctree-l1"><a class="reference internal" href="basefold-04.zh.html">Basefold 笔记：Random Foldable Codes</a></li>
<li class="toctree-l1"><a class="reference internal" href="basefold-05.zh.html">Basefold 笔记：IOPP 可靠性分析</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">FRI</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../fri/BBHR18-FRI.zh.html">[BBHR18] FRI 论文 soundness 解析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fri/BCIKS20-proximity-gaps.zh.html">[BCIKS20] Proximity Gaps 论文 soundness 解析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fri/fri-proximity-gap.zh.html">Proximity Gaps 与 Correlated Agreement：FRI 安全性证明的核心</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fri/stir.zh.html">STIR: 提升码率来降低查询复杂度</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fri/whir.zh.html">WHIR: Reed-Solomon Proximity Testing with Super-Fast Verification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fri/deepfold.zh.html">DeepFold 笔记：协议概览</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">FRI Binius</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../fri-binius/binius-01.zh.html">Notes on FRI-Binius (Part I): Binary Towers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fri-binius/binius-02.zh.html">Notes on Binius (Part II): Subspace Polynomial</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Zeromorph</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../zeromorph/zeromorph.zh.html">ZeroMorph 笔记</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zeromorph/zeromorph-fri.zh.html">Zeromorph-PCS : 对接 FRI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zeromorph/zeromorph_mapping_tutorial.html">Select SageMath Kernel First</a></li>


</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2Fbasefold/basefold-05.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/basefold/basefold-05.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Notes on Basefold (Part V): IOPP Soundness</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#iopp-protocol">IOPP Protocol</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#analysis-approach">Analysis Approach</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#iopp-soundness-theorem">IOPP Soundness Theorem</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proof-of-case-1">Proof of Case 1</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proof-of-case-2">Proof of Case 2</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="notes-on-basefold-part-v-iopp-soundness">
<h1>Notes on Basefold (Part V): IOPP Soundness<a class="headerlink" href="#notes-on-basefold-part-v-iopp-soundness" title="Link to this heading">#</a></h1>
<ul class="simple">
<li><p>Jade Xie <a class="reference external" href="mailto:jade&#37;&#52;&#48;secbit&#46;io">jade<span>&#64;</span>secbit<span>&#46;</span>io</a></p></li>
<li><p>Yu Guo <a class="reference external" href="mailto:yu&#46;guo&#37;&#52;&#48;secbit&#46;io">yu<span>&#46;</span>guo<span>&#64;</span>secbit<span>&#46;</span>io</a></p></li>
</ul>
<p>In this article, we will outline the proof approach for IOPP soundness presented in the [ZCF23] paper, which is similar to the soundness proof for the FRI protocol in [BKS18]. It employs a binary tree method to analyze points where the Prover might cheat, a concept also appearing in the soundness proof of the DEEP-FRI protocol in [BGKS20].</p>
<section id="iopp-protocol">
<h2>IOPP Protocol<a class="headerlink" href="#iopp-protocol" title="Link to this heading">#</a></h2>
<p>The IOPP protocol has been thoroughly introduced in the second article above. For the analysis in the later sections, we will briefly outline the IOPP protocol here. It is an extension of the FRI protocol, and the process of understanding the protocol can fully leverage the understanding of the FRI protocol, as both the commit and query phases are consistent.</p>
<p><strong>Protocol 1 [ZCF23, Protocol 2] IOPP.commit</strong></p>
<p>Input oracle: <span class="math notranslate nohighlight">\(\pi_d \in \mathbb{F}^{n_d}\)</span><br />
Output oracles: <span class="math notranslate nohighlight">\((\pi_{d-1}, \ldots, \pi_0) \in \mathbb{F}^{n_{d-1}} \times \cdots \times \mathbb{F}^{n_0}\)</span></p>
<ul class="simple">
<li><p>For <span class="math notranslate nohighlight">\(i\)</span> from <span class="math notranslate nohighlight">\(d-1\)</span> down to <span class="math notranslate nohighlight">\(0\)</span>:</p>
<ol class="arabic simple">
<li><p>Verifier samples and sends <span class="math notranslate nohighlight">\(\alpha_i \leftarrow \$ \mathbb{F}\)</span> from <span class="math notranslate nohighlight">\(\mathbb{F}\)</span> to Prover</p></li>
<li><p>For each index <span class="math notranslate nohighlight">\(j \in [1, n_i]\)</span>, Prover:
a. Sets <span class="math notranslate nohighlight">\(f(X) := \mathrm{interpolate}((\mathrm{diag}(T_i)[j], \pi_{i+1}[j]), (\mathrm{diag}(T'_i)[j], \pi_{i+1}[j+n_i]))\)</span>
b. Sets <span class="math notranslate nohighlight">\(\pi_i[j] = f(\alpha_i)\)</span></p></li>
<li><p>Prover outputs oracle <span class="math notranslate nohighlight">\(\pi_i \in \mathbb{F}^{n_i}\)</span>.</p></li>
</ol>
</li>
</ul>
<p><strong>Protocol 2 [ZCF23, Protocol 3] IOPP.query</strong></p>
<p>Input oracles: <span class="math notranslate nohighlight">\((\pi_{d-1}, \ldots, \pi_0) \in \mathbb{F}^{n_{d-1}} \times \ldots \times \mathbb{F}^{n_0}\)</span><br />
Output: accept or reject</p>
<ul class="simple">
<li><p>Verifier samples <span class="math notranslate nohighlight">\(\mu \leftarrow \$ [1, n_{d-1}]\)</span></p></li>
<li><p>For <span class="math notranslate nohighlight">\(i\)</span> from <span class="math notranslate nohighlight">\(d-1\)</span> down to <span class="math notranslate nohighlight">\(0\)</span>, Verifier:</p>
<ol class="arabic simple">
<li><p>Queries oracle <span class="math notranslate nohighlight">\(\pi_{i+1}[\mu], \pi_{i+1}[\mu + n_i]\)</span></p></li>
<li><p>Computes <span class="math notranslate nohighlight">\(p(X) := \mathrm{interpolate}((\mathrm{diag}(T_i)[\mu], \pi_{i+1}[\mu]), (\mathrm{diag}(T'_i)[\mu], \pi_{i+1}[\mu + n_i]))\)</span></p></li>
<li><p>Checks <span class="math notranslate nohighlight">\(p(\alpha_i) = \pi_i[\mu]\)</span></p></li>
<li><p>If <span class="math notranslate nohighlight">\(i &gt; 0\)</span> and <span class="math notranslate nohighlight">\(\mu &gt; n_i - 1\)</span>, then updates <span class="math notranslate nohighlight">\(\mu \leftarrow \mu - n_{i - 1}\)</span></p></li>
</ol>
</li>
<li><p>If <span class="math notranslate nohighlight">\(\pi_0\)</span> is a valid codeword with respect to the generator matrix <span class="math notranslate nohighlight">\(\mathbf{G}_0\)</span>, output <code class="docutils literal notranslate"><span class="pre">accept</span></code>; otherwise, output <code class="docutils literal notranslate"><span class="pre">reject</span></code>.</p></li>
</ul>
</section>
<section id="analysis-approach">
<h2>Analysis Approach<a class="headerlink" href="#analysis-approach" title="Link to this heading">#</a></h2>
<p>The analysis of IOPP soundness examines, for any Prover who might cheat, what is the maximum probability that the Verifier outputs <code class="docutils literal notranslate"><span class="pre">accept</span></code> in such a scenario. We aim for this probability to be sufficiently small to ensure the protocol’s security. Naturally, this probability depends on certain parameters of the protocol, and in practice, we desire it to be below a predetermined security parameter <span class="math notranslate nohighlight">\(\lambda\)</span> (for example, <span class="math notranslate nohighlight">\(\lambda\)</span> could be set to <span class="math notranslate nohighlight">\(128\)</span> or <span class="math notranslate nohighlight">\(256\)</span>), meaning that this probability should be less than <span class="math notranslate nohighlight">\(2^{-\lambda}\)</span>.</p>
<p>Let us now examine areas within the IOPP protocol where a cheating Prover might exploit to cause the Verifier to output <code class="docutils literal notranslate"><span class="pre">accept</span></code>. We note that there are two points where the Verifier introduces randomness:</p>
<ol class="arabic simple">
<li><p>In the IOPP.commit phase, step 1 of the protocol, the Verifier selects a random number <span class="math notranslate nohighlight">\(\alpha_{i}\)</span> from <span class="math notranslate nohighlight">\(\mathbb{F}\)</span> and sends it to the Prover, who uses it to fold the original <span class="math notranslate nohighlight">\(\pi_{i+1}\)</span> to obtain <span class="math notranslate nohighlight">\(\pi_i\)</span>.</p></li>
<li><p>In the IOPP.query phase, step 1 of the protocol, the Verifier samples <span class="math notranslate nohighlight">\(\mu \leftarrow \$ [1, n_{d-1}]\)</span> and then checks whether the Prover’s folding was correct.</p></li>
</ol>
<p>Suppose the initial cheating Prover provides a <span class="math notranslate nohighlight">\(\pi_{d}\)</span> that is <span class="math notranslate nohighlight">\(\delta\)</span> away from <span class="math notranslate nohighlight">\(C_{d}\)</span>. We aim for the Verifier to ultimately check that <span class="math notranslate nohighlight">\(\pi_{0}\)</span> is also at least <span class="math notranslate nohighlight">\(\delta\)</span> away from <span class="math notranslate nohighlight">\(C_0\)</span>, meaning that the <span class="math notranslate nohighlight">\(\delta\)</span> distance is preserved throughout the folding process. Another scenario is detecting that the Prover did not fold correctly. We consider two cases:</p>
<ol class="arabic">
<li><p>The Prover is extremely lucky, and the random number <span class="math notranslate nohighlight">\(\alpha_{i}\)</span> chosen by the Verifier causes the folded <span class="math notranslate nohighlight">\(\pi_i\)</span> to be less than <span class="math notranslate nohighlight">\(\delta\)</span> away from the corresponding <span class="math notranslate nohighlight">\(C_i\)</span>, leading the Verifier to output <code class="docutils literal notranslate"><span class="pre">accept</span></code>. We consider this situation very lucky for the Prover because, according to the Proximity Gaps theorem, the probability of such an event is exceedingly small (assuming this probability is <span class="math notranslate nohighlight">\(\epsilon\)</span>), such that its occurrence is akin to the Prover winning the lottery.</p></li>
<li><p>The Prover is not as lucky as in Case 1. In this scenario, after folding with the random number, the message <span class="math notranslate nohighlight">\(\pi_i\)</span> still remains at least <span class="math notranslate nohighlight">\(\delta\)</span> away from the corresponding <span class="math notranslate nohighlight">\(C_i\)</span>. Since the Verifier randomly selects <span class="math notranslate nohighlight">\(\mu \leftarrow \$ [1,n_{d-1}]\)</span> in the IOPP.query phase and only checks a subset of the Prover’s foldings, this provides an opportunity for the Prover to potentially evade Verifier checks. For example, if after folding, the message <span class="math notranslate nohighlight">\(a\)</span> satisfies <span class="math notranslate nohighlight">\(\Delta(a, C) &gt; \delta\)</span> in relative Hamming distance, i.e., <span class="math notranslate nohighlight">\(\Delta(a, C) &gt; \delta\)</span>. The Verifier will randomly check <span class="math notranslate nohighlight">\(a[i]\)</span> against <span class="math notranslate nohighlight">\(c[i]\)</span>, and if they are unequal, the Verifier will reject.</p>
<p><img alt="" src="../_images/basefold-05-delta.svg" /></p>
<p>Since <span class="math notranslate nohighlight">\(\Delta(a, C) &gt; \delta\)</span>, more than a <span class="math notranslate nohighlight">\(\delta\)</span> proportion of the components in <span class="math notranslate nohighlight">\(a\)</span> differ from the codewords in the encoding space. When the Verifier selects one of these differing positions, it will reject, hence the probability that the Verifier catches the Prover cheating exceeds <span class="math notranslate nohighlight">\(\delta\)</span>.</p>
<p><img alt="" src="../_images/basefold-05-delta-reject.svg" /></p>
<p>If the Verifier queries <span class="math notranslate nohighlight">\(l\)</span> times, the probability that the Prover can pass all Verifier checks is at most <span class="math notranslate nohighlight">\((1 - \delta)^{l}\)</span>.</p>
</li>
</ol>
<p>Combining the two cases, the probability that the cheating Prover succeeds is bounded above by</p>
<div class="math notranslate nohighlight">
\[
\epsilon + (1 - \delta)^{l} \tag{1}
\]</div>
<p>This represents an overall analysis approach. The specific expression may vary, but the following IOPP soundness theorem will elaborate further.</p>
</section>
<section id="iopp-soundness-theorem">
<h2>IOPP Soundness Theorem<a class="headerlink" href="#iopp-soundness-theorem" title="Link to this heading">#</a></h2>
<p><strong>Theorem 1</strong> [ZCF23, Theorem 3] (IOPP Soundness for Foldable Linear Codes) Let <span class="math notranslate nohighlight">\(C_d\)</span> be a <span class="math notranslate nohighlight">\((c, k_0, d)\)</span> foldable linear code with generator matrices <span class="math notranslate nohighlight">\((G_0, \ldots, G_d)\)</span>. Let <span class="math notranslate nohighlight">\(C_i\)</span> (<span class="math notranslate nohighlight">\(0 \le i &lt; d\)</span>) denote the code generated by <span class="math notranslate nohighlight">\(G_i\)</span>, and assume that for all <span class="math notranslate nohighlight">\(i \in [0, d-1]\)</span>, the relative minimum distance <span class="math notranslate nohighlight">\(\Delta C_i \ge \Delta C_{i+1}\)</span>. Let <span class="math notranslate nohighlight">\(\gamma &gt; 0\)</span>, and set <span class="math notranslate nohighlight">\(\delta := \min(\Delta^*(\pi_d, C_d), J_{\gamma}(J_{\gamma}(\Delta_{C_d})))\)</span>, where <span class="math notranslate nohighlight">\(\Delta^*(\pi_d, C_d)\)</span> is the relative coset minimum distance between <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> and <span class="math notranslate nohighlight">\(C_d\)</span>. Then, for any (adaptively chosen) Prover oracles <span class="math notranslate nohighlight">\(\pi_{d-1}, \ldots, \pi_0\)</span>, the Verifier in the IOPP.query phase repeated <span class="math notranslate nohighlight">\(\ell\)</span> times outputs <code class="docutils literal notranslate"><span class="pre">accept</span></code> with probability at most <span class="math notranslate nohighlight">\((1 - \delta + \gamma d)^{\ell}\)</span>.</p>
<p>The term <span class="math notranslate nohighlight">\(J_{\gamma}(J_{\gamma}(\Delta_{C_d}))\)</span> mentioned in the theorem refers to the composition of two Johnson functions, defined as follows.</p>
<p><strong>Definition 1</strong> [ZCF23, Definition 4] (Johnson Bound) For any <span class="math notranslate nohighlight">\(\gamma \in (0,1]\)</span>, define <span class="math notranslate nohighlight">\(J_{\gamma}: [0,1] \rightarrow [0,1]\)</span> as</p>
<div class="math notranslate nohighlight">
\[
J_{\gamma}(\lambda) := 1 - \sqrt{1 - \lambda(1 - \gamma)} .
\]</div>
<p>The definition of relative coset minimum distance is as follows.</p>
<p><strong>Definition 2</strong> [ZCF23, Definition 5] (Relative Coset Minimum Distance) Let <span class="math notranslate nohighlight">\(n\)</span> be an even number, and let <span class="math notranslate nohighlight">\(C\)</span> be a <span class="math notranslate nohighlight">\([n,k,d]\)</span> error-correcting code. For a vector <span class="math notranslate nohighlight">\(\mathbf{v} \in \mathbb{F}^{n}\)</span> and a codeword <span class="math notranslate nohighlight">\(c \in C\)</span>, the relative distance <span class="math notranslate nohighlight">\(\Delta^*(\mathbf{v},c)\)</span> between <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> and <span class="math notranslate nohighlight">\(c\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[
\Delta^*(\mathbf{v},c) = \frac{2 |\{ j \in [1, n/2]: \mathbf{v}[j]  \neq c[j] \vee \mathbf{v}[j + n/2]  \neq c[j + n/2] \}  |}{n}.
\]</div>
<p>This definition is similar to the block-wise distance definition used in [BBHR18] to prove soundness ([BBHR18, Definition 3.2]). It is an alternative version of the relative minimum Hamming distance. Pairs <span class="math notranslate nohighlight">\(\{j,j+n/2\}\)</span> are considered as a pair, corresponding to a coset, analogous to the FRI protocol. For example, for <span class="math notranslate nohighlight">\(n = 8\)</span>, let the generator be <span class="math notranslate nohighlight">\(\omega\)</span> with <span class="math notranslate nohighlight">\(\omega^8 = 1\)</span>, and select the mapping <span class="math notranslate nohighlight">\(x \mapsto x^2\)</span>, then it can be seen that <span class="math notranslate nohighlight">\(\{1,5\}\)</span>, <span class="math notranslate nohighlight">\(\{2,6\}\)</span>, <span class="math notranslate nohighlight">\(\{3,7\}\)</span>, <span class="math notranslate nohighlight">\(\{4,8\}\)</span> correspond to elements that form a coset, resulting in a total of 4 cosets.</p>
<p><img alt="" src="../_images/basefold-05-coset-example.svg" /></p>
<p><span class="math notranslate nohighlight">\(\Delta^*(\mathbf{v},c)\)</span> measures the proportion of cosets in which <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> and <span class="math notranslate nohighlight">\(c\)</span> are not entirely consistent.</p>
<p><img alt="" src="../_images/basefold-05-coset-distance.svg" /></p>
<p>Let <span class="math notranslate nohighlight">\(\Delta^*(\mathbf{v},C) := \min_{c \in C}\Delta^*(\mathbf{v},c)\)</span>. Then, it relates to the relative minimum Hamming distance as follows: <span class="math notranslate nohighlight">\(\Delta(\mathbf{v},C) \le \Delta^*(\mathbf{v},C)\)</span>.</p>
<p>Despite introducing these different definitions and Johnson functions, the proof approach for IOPP soundness remains consistent with the earlier outlined analysis, discussing two cases. Our aim is to analyze the probability that a cheating Prover can pass all Verifier checks and ultimately output <code class="docutils literal notranslate"><span class="pre">accept</span></code>. The proof approach is as follows:</p>
<p><strong>Case 1</strong>: The Prover is extremely lucky. Due to the Verifier selecting random numbers <span class="math notranslate nohighlight">\(\alpha_i\)</span>, the folded messages are sufficiently close to the encoding space, allowing the Prover to pass all subsequent Verifier checks. For the Verifier, this corresponds to some “bad” events occurring, where there exists an <span class="math notranslate nohighlight">\(i \in [0, d-1]\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
\Delta(\mathrm{fold}_{\alpha_i}(\pi_{i+1}), C_i) \le \min(\Delta^*(\pi_{i+1}, C_{i+1}), J_{\gamma}(J_{\gamma}(\Delta_{C_d}))) - \gamma
\]</div>
<p>Using proof by contradiction through the Correlated Agreement theorem (which can derive the corresponding Proximity Gaps theorem), it can be shown that the probability of such “bad” events is small, proven to be at most <span class="math notranslate nohighlight">\(\frac{2d}{\gamma^3 |\mathbb{F}|}\)</span>.</p>
<p><strong>Case 2</strong>: Suppose the Prover is not as lucky, meaning that the “bad” events described in Case 1 do not occur. Then, in the IOPP.query phase, the Verifier selects <span class="math notranslate nohighlight">\(\mu \leftarrow \$ [1, n_{d-1}]\)</span>, and in this scenario, the Prover might evade the Verifier’s checks by having the Verifier select points where the Prover has not cheated. Repeating the IOPP.query phase <span class="math notranslate nohighlight">\(l\)</span> times, the probability that the Prover manages to pass each check is at most <span class="math notranslate nohighlight">\((1 - \delta + \gamma d)^{l}\)</span>.</p>
<p>Combining Cases 1 and 2, for foldable linear codes, the IOPP Soundness is at least</p>
<div class="math notranslate nohighlight">
\[
\mathbf{s}^-(\delta) = 1 - \left(\frac{2d}{\gamma^3 |\mathbb{F}|} + \left(1 - \delta + \gamma d \right)^l \right) .
\]</div>
<p>Thus, Theorem 1 is proven.</p>
<section id="proof-of-case-1">
<h3>Proof of Case 1<a class="headerlink" href="#proof-of-case-1" title="Link to this heading">#</a></h3>
<p>The following Corollary 1 demonstrates that for any specific <span class="math notranslate nohighlight">\(i\)</span>, the probability that after folding, the result is within a relative Hamming distance <span class="math notranslate nohighlight">\(\delta - \gamma\)</span> of <span class="math notranslate nohighlight">\(C_i\)</span>, denoted as event <span class="math notranslate nohighlight">\(B^{(i)}\)</span>, is at most <span class="math notranslate nohighlight">\(\frac{2}{\gamma^3 |\mathbb{F}|}\)</span>. Therefore, if certain events <span class="math notranslate nohighlight">\(B_i\)</span> occur, their probability does not exceed the sum of the probabilities of these <span class="math notranslate nohighlight">\(B_i\)</span> events, i.e.,</p>
<div class="math notranslate nohighlight">
\[
\Pr\left[\bigcup_{i = 0}^{d-1} B^{(i)} \right] \le \sum_{i = 0}^{d-1} \Pr[B^{(i)}] \le \frac{2d}{\gamma^3 |\mathbb{F}|}.
\]</div>
<p>Let us examine Corollary 1 in detail.</p>
<p><strong>Corollary 1</strong> [ZCF23, Corollary 1] For any fixed <span class="math notranslate nohighlight">\(i \in [0, d-1]\)</span> and <span class="math notranslate nohighlight">\(\gamma, \delta &gt; 0\)</span>, such that <span class="math notranslate nohighlight">\(\delta \le J_{\gamma}(J_{\gamma}(\Delta_{C_d}))\)</span>, if <span class="math notranslate nohighlight">\(\Delta^*(\mathbf{v}, C_{i+1}) &gt; \delta\)</span>, then</p>
<div class="math notranslate nohighlight">
\[
\Pr_{\alpha_i \leftarrow \$ \mathbb{F}}[\Delta(\mathrm{fold}_{\alpha_i}(\mathbf{v}), C_i) \le \delta - \gamma] \le \frac{2}{\gamma^3 |\mathbb{F}|}. \tag{2}
\]</div>
<p>The function <span class="math notranslate nohighlight">\(\mathrm{fold}_{\alpha_i}(\cdot)\)</span> is defined as follows. Let <span class="math notranslate nohighlight">\(\mathbf{u},\mathbf{u'} \in \mathbf{F}^{n_i}\)</span> be the unique interpolated vectors such that</p>
<div class="math notranslate nohighlight">
\[
\pi_{i+1} = (\mathbf{u} + \mathrm{diag}(T_i) \circ \mathbf{u}', \mathbf{u} + \mathrm{diag}(T_i') \circ \mathbf{u}')
\]</div>
<p>Then, <span class="math notranslate nohighlight">\(\mathrm{fold}_{\alpha_i}(\pi_{i+1})\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[
\mathrm{fold}_{\alpha_i}(\pi_{i+1}) := \mathbf{u}' + \alpha_i \mathbf{u}.
\]</div>
<p>This essentially represents the process of folding <span class="math notranslate nohighlight">\(\pi_{i+1}\)</span> with the random number <span class="math notranslate nohighlight">\(\alpha_i\)</span>.</p>
<p>Corollary 1 generalizes [BKS18] Corollary 7.3 to general foldable linear codes.</p>
<p><em><strong>Proof Idea of Corollary 1:</strong></em> To prove that the relative Hamming distance after folding with the random number <span class="math notranslate nohighlight">\(\alpha_i\)</span> is smaller than the original distance is a rare event, specifically not exceeding <span class="math notranslate nohighlight">\(\frac{2}{\gamma^3 |\mathbb{F}|}\)</span>. Suppose, for contradiction, that this event occurs with a significantly higher probability. Then, by directly applying the Correlated Agreement theorem (from [BKS18] Theorem 4.4), it can be shown that for the affine space <span class="math notranslate nohighlight">\(U = \{\mathbf{u} + x \mathbf{u'} : x \in \mathbb{F}\}\)</span>, there exists a sufficiently large Correlated Agree subset <span class="math notranslate nohighlight">\(T\)</span> within <span class="math notranslate nohighlight">\(C_i\)</span> such that there exist <span class="math notranslate nohighlight">\(\mathbf{w}, \mathbf{w'} \in C_i\)</span> agreeing with <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{u'}\)</span> on <span class="math notranslate nohighlight">\(T\)</span>, respectively. Encoding <span class="math notranslate nohighlight">\(\mathbf{w}, \mathbf{w'}\)</span> yields a codeword <span class="math notranslate nohighlight">\(c_{w}\)</span> in <span class="math notranslate nohighlight">\(C_{i+1}\)</span>, thereby estimating <span class="math notranslate nohighlight">\(\Delta^{*}(\mathbf{v}, C_{i+1}) \le \delta\)</span>, which contradicts our assumption. Therefore, the corollary holds.</p>
</section>
<section id="proof-of-case-2">
<h3>Proof of Case 2<a class="headerlink" href="#proof-of-case-2" title="Link to this heading">#</a></h3>
<p>To prove that repeating the IOPP.query phase <span class="math notranslate nohighlight">\(l\)</span> times results in the Verifier outputting <code class="docutils literal notranslate"><span class="pre">accept</span></code> with probability at most <span class="math notranslate nohighlight">\((1 - \delta + \gamma d)^l\)</span>, we merely need to demonstrate that, in one execution of IOPP.query, the probability that the Verifier outputs <code class="docutils literal notranslate"><span class="pre">reject</span></code> is at least <span class="math notranslate nohighlight">\(\delta - \gamma d\)</span>.</p>
<p>Using the binary tree concept for the proof, we first define a “bad” node <span class="math notranslate nohighlight">\((i,\mu)\)</span>, as shown in the figure below. These are the points where the Prover fails to pass step 3 of the IOPP.query protocol, meaning that after the Verifier selects a random number <span class="math notranslate nohighlight">\(\mu\)</span>, for any <span class="math notranslate nohighlight">\(i \in [0, d-1]\)</span> and <span class="math notranslate nohighlight">\(\mu \in [n_i]\)</span>, the Verifier computes in step 2 of IOPP.query:</p>
<div class="math notranslate nohighlight">
\[
p(X) := \mathrm{interpolate}((\mathrm{diag}(T_i)[\mu], \pi_{i+1}[\mu]), (\mathrm{diag}(T'_i)[\mu], \pi_{i+1}[\mu + n_i]))
\]</div>
<p>Subsequently, in step 3 of the IOPP.query protocol, the Verifier checks whether</p>
<div class="math notranslate nohighlight">
\[
p(\alpha_i) \neq \pi_i[\mu]
\]</div>
<p>At this point, we say that the node <span class="math notranslate nohighlight">\((i,\mu)\)</span> is “bad”.</p>
<p><img alt="" src="../_images/basefold-05-badnode.svg" /></p>
<p>Next, consider <span class="math notranslate nohighlight">\(i\)</span> from <span class="math notranslate nohighlight">\(d-1\)</span> down to <span class="math notranslate nohighlight">\(0\)</span>. For any <span class="math notranslate nohighlight">\(\mu \in [1, n_{d-1}]\)</span>, <span class="math notranslate nohighlight">\(\mu\)</span> can generate a binary tree, forming <span class="math notranslate nohighlight">\(n_{0}\)</span> such binary trees as depicted below.</p>
<p><img alt="" src="../_images/basefold-05-binarytree.svg" /></p>
<p>If there exists at least one “bad” node <span class="math notranslate nohighlight">\((i,\mu)\)</span> within any of these trees—assuming that all nodes from layers <span class="math notranslate nohighlight">\(d-1\)</span> down to <span class="math notranslate nohighlight">\(i +1\)</span> and their children are “good”, i.e., they pass step 3 of the IOPP.query protocol—then when a “bad” node occurs at level <span class="math notranslate nohighlight">\(i\)</span>, the Verifier will reject. As shown in the figure, nodes from levels <span class="math notranslate nohighlight">\(i +1\)</span> to <span class="math notranslate nohighlight">\(d-1\)</span> are all “good”. This implies that as long as there is at least one bad node in the entire tree, the Verifier will reject. If we let <span class="math notranslate nohighlight">\(\beta_i\)</span> denote the ratio of “bad” nodes at layer <span class="math notranslate nohighlight">\(i\)</span>, then the probability that the Verifier rejects at layer <span class="math notranslate nohighlight">\(i\)</span> is <span class="math notranslate nohighlight">\(\beta_i\)</span>. Considering the entire IOPP.query phase, the Verifier’s probability of rejection is thus <span class="math notranslate nohighlight">\(\sum_{i=0}^{d-1}\beta_i\)</span>, where <span class="math notranslate nohighlight">\(\beta_i := \Delta(\pi_i, \mathrm{fold}_{\alpha_i}(\pi_{i+1}))\)</span>, representing those “bad” points where the folded <span class="math notranslate nohighlight">\(\pi_{i+1}\)</span> does not agree with <span class="math notranslate nohighlight">\(\pi_i\)</span>.</p>
<p>Thus, the remaining task is to estimate <span class="math notranslate nohighlight">\(\sum_{i=0}^{d-1}\beta_i\)</span>. [ZCF23, Claim 2] provides inequalities for each <span class="math notranslate nohighlight">\(\beta_i\)</span>.</p>
<p><strong>Claim 1</strong> [ZCF23, Claim 2] For any <span class="math notranslate nohighlight">\(i \in [0, d]\)</span>, define <span class="math notranslate nohighlight">\(\delta^{(i)} := \min(\Delta^*(\pi_i, C_i), J_{\gamma}(J_{\gamma}(\Delta_{C_d})))\)</span>. For all <span class="math notranslate nohighlight">\(i \in [0, d-1]\)</span>,</p>
<div class="math notranslate nohighlight">
\[
\beta_i \ge \delta^{(i+1)} - \delta^{(i)} - \gamma .
\]</div>
<p>Under the soundness conditions, <span class="math notranslate nohighlight">\(\delta = \delta^{(d)}\)</span>. Also, since <span class="math notranslate nohighlight">\(\Delta^{*}(\pi_0, C_0) = \Delta(\pi_0, C_0) = 0\)</span>, we have <span class="math notranslate nohighlight">\(\delta^{(0)} = 0\)</span>. Thus, according to the claim:</p>
<div class="math notranslate nohighlight">
\[
\delta = \delta^{(d)} - \delta^{(0)} = \sum_{i = 0}^{d-1} \delta^{(i+1)} - \delta^{(i)} \le \sum_{i = 0}^{d-1} \beta_i + \gamma d,
\]</div>
<p>hence,</p>
<div class="math notranslate nohighlight">
\[
\sum_{i = 0}^{d-1} \beta_i \ge \delta - \gamma d.
\]</div>
<p>Therefore, if no bad event <span class="math notranslate nohighlight">\(B\)</span> occurs, executing the IOPP.query phase once, the probability that the Verifier rejects is at least <span class="math notranslate nohighlight">\(\delta - \gamma d\)</span>. This concludes the proof of Case 2.</p>
</section>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>[BBHR18] Eli Ben-Sasson, Iddo Bentov, Ynon Horesh, and Michael Riabzev. Fast Reed-Solomon Interactive Oracle Proofs of Proximity. In Proceedings of the 45th International Colloquium on Automata, Languages, and Programming (ICALP), 2018. Available online as Report 134-17 on Electronic Colloquium on Computational Complexity.</p></li>
<li><p>[BGKS20] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI: sampling outside the box improves soundness. In Thomas Vidick, editor, 11th Innovations in Theoretical Computer Science Conference, ITCS 2020, January 12-14, 2020, Seattle, Washington, USA, volume 151 of LIPIcs, pages 5:1–5:32. Schloss Dagstuhl-Leibniz-Zentrum für Informatik, 2020.</p></li>
<li><p>[BKS18] Eli Ben-Sasson, Swastik Kopparty, and Shubhangi Saraf. “Worst-Case to Average Case Reductions for the Distance to a Code”. In: Proceedings of the 33rd Computational Complexity Conference. CCC ’18. San Diego, California: Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2018. ISBN: 9783959770699.</p></li>
<li><p>[ZCF23] Hadas Zeilberger, Binyi Chen, and Ben Fisch. “BaseFold: efficient field-agnostic polynomial commitment schemes from foldable codes.” Annual International Cryptology Conference. Cham: Springer Nature Switzerland, 2024.</p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./basefold"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#iopp-protocol">IOPP Protocol</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#analysis-approach">Analysis Approach</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#iopp-soundness-theorem">IOPP Soundness Theorem</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proof-of-case-1">Proof of Case 1</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#proof-of-case-2">Proof of Case 2</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#references">References</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By The Jupyter Book community
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>